// <auto-generated>
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>

namespace Azure.Maps.Mobility
{
    using Microsoft.Rest;
    using Models;
    using Newtonsoft.Json;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using System.Net;
    using System.Net.Http;
    using System.Threading;
    using System.Threading.Tasks;

    /// <summary>
    /// MobilityOperations operations.
    /// </summary>
    public partial class MobilityOperations : IServiceOperations<MobilityClient>, IMobilityOperations
    {
        /// <summary>
        /// Initializes a new instance of the MobilityOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        public MobilityOperations(MobilityClient client)
        {
            if (client == null)
            {
                throw new System.ArgumentNullException("client");
            }
            Client = client;
        }

        /// <summary>
        /// Gets a reference to the MobilityClient
        /// </summary>
        public MobilityClient Client { get; private set; }

        /// <summary>
        /// **Metro Area API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Service allows users to request metro areas in which the Azure Maps
        /// Mobility Service is available. The service supports filtering results by
        /// country or coordinate location. Information returned includes Metro Area
        /// details such as metro Id, name and a representation of the metro area
        /// geometry in GeoJSON format.
        /// </summary>
        /// <param name='query'>
        /// The applicable location input. Can be position (specified as a comma
        /// separated string composed by latitude followed by longitude e.g.
        /// "47.641268,-122.125679") or  countryCode (2-character ISO country code).
        /// </param>
        /// <param name='queryType'>
        /// The type of the query. By default originType=position, specified as a comma
        /// separated string composed by latitude followed by longitude, e.g.
        /// "47.641268,-122.125679‚Äù. Possible values include: 'position', 'countryCode'
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<MetroAreaResponse>> GetMetroAreaPreviewWithHttpMessagesAsync(string query, string queryType = default(string), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("query", query);
                tracingParameters.Add("queryType", queryType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMetroAreaPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/metroArea/id/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (queryType != null)
            {
                _queryParameters.Add(string.Format("queryType={0}", System.Uri.EscapeDataString(queryType)));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<MetroAreaResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<MetroAreaResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Metro Area Info API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Service allows users to request additional information for metro areas in
        /// which the Azure Maps Mobility services are available. Information such as
        /// supported transit types, transit agencies and active alerts is available,
        /// depending on the options selected. Also, the service returns information if
        /// the public transit fare information is available for the requested metro
        /// area.
        /// </summary>
        /// <param name='query'>
        /// metroId. The unique id of the metro area. Required parameter specifying the
        /// required metro area to search in. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityTransitRoute).
        /// </param>
        /// <param name='detailType'>
        /// Specify details requested respective to the metro area as a comma separated
        /// list. Supported values are:
        /// * `agencies` - Return a list of all public transit agencies operating in
        /// the given metro area.
        /// * `alerts` - Returns a list of all active service alerts, that are defined
        /// in the metro or agency level, and are not connected to a specific line or
        /// stop.
        /// * `alertDetails` - Applicable only when alerts are requested. Returns
        /// details of the alerts.
        /// * `transitTypes` - Returns a list of all supported transit types in the
        /// given metro area.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<MetroAreaInfoResponse>> GetMetroAreaInfoPreviewWithHttpMessagesAsync(int query, IList<string> detailType, string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (detailType == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "detailType");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("query", query);
                tracingParameters.Add("detailType", detailType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetMetroAreaInfoPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/metroArea/info/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(query, Client.SerializationSettings).Trim('"'))));
            if (detailType != null)
            {
                _queryParameters.Add(string.Format("detailType={0}", System.Uri.EscapeDataString(string.Join(",", detailType))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<MetroAreaInfoResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<MetroAreaInfoResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Find Nearby Transit API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Get Nearby Transit service allows you to search public transit stops around
        /// a given location  returning the transit object details. Service allows
        /// users to search for public transit stops within a given radius returning a
        /// set of stops with stop details. Additional  information such as transit
        /// operator information is returned depending on the options selected. The
        /// returned information can be used for further processing such as requesting
        /// [real-time arrivals](https://aka.ms/AzureMapsMobilityRealTimeArrivals) for
        /// the stop or [transit stop
        /// details](https://aka.ms/AzureMapsMobilityTransitStop) such as main transit
        /// type of most lines stopping for a given public, active service alerts or
        /// main transport agency.
        /// </summary>
        /// <param name='query'>
        /// Location input from user. The applicable location query specified as a
        /// comma separated string  composed by latitude followed by longitude e.g.
        /// "47.641268,-122.125679".
        /// </param>
        /// <param name='metroId'>
        /// The unique id of the metro area. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityMetro).
        /// </param>
        /// <param name='limit'>
        /// Maximum number of responses that will be returned. Default is 3, minimum 1
        /// and maximum 100. Sort order is based on distance from input location.
        /// </param>
        /// <param name='radius'>
        /// Specifies the search area to constrain a search. The radius in meters  to
        /// for the results to be constrained to the defined area. Default value is 30
        /// meters, minimum 1 meter and maximum 5000 meters (5km).
        /// </param>
        /// <param name='objectType'>
        /// The transit object type. By default, objectType is set to `stop`
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<NearbyTransitResponse>> GetNearbyTransitPreviewWithHttpMessagesAsync(string query, int? metroId = default(int?), int? limit = default(int?), int? radius = default(int?), string objectType = default(string), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("metroId", metroId);
                tracingParameters.Add("query", query);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("radius", radius);
                tracingParameters.Add("objectType", objectType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetNearbyTransitPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/transit/nearby/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (metroId != null)
            {
                _queryParameters.Add(string.Format("metroId={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(metroId, Client.SerializationSettings).Trim('"'))));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(limit, Client.SerializationSettings).Trim('"'))));
            }
            if (radius != null)
            {
                _queryParameters.Add(string.Format("radius={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(radius, Client.SerializationSettings).Trim('"'))));
            }
            if (objectType != null)
            {
                _queryParameters.Add(string.Format("objectType={0}", System.Uri.EscapeDataString(objectType)));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<NearbyTransitResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<NearbyTransitResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Transit Line Info API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Your scenario might require requesting transit line specific data such as
        /// stops and line geometry. Transit Line Info service  allows you to request
        /// line group by line group id returning a line group comprised a set of
        /// lines.  Additional information such  as 24 hours static schedule, active
        /// alerts for the line group and line patterns is also available, depending on
        /// the options  selected. Mobility services uses a parallel data model for
        /// public transit lines and line groups. Usually line group contains  2 lines,
        /// one going from A to B, and the other returning from B to A, both operating
        /// by the same Public Transport Agency having  the same line number. We
        /// recommend you review our guidance
        /// [article](https://aka.ms/AMapsPublicTRansitConcepts) to understand  the
        /// concepts of lines and line groups.
        /// </summary>
        /// <param name='query'>
        /// lineGroupId, for example,'666074'. Typically contains 2 lines having the
        /// same agency and line, one going from A to B, and the other from B to A.
        /// </param>
        /// <param name='metroId'>
        /// The unique id of the metro area. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityMetro).
        /// </param>
        /// <param name='detailType'>
        /// Specify additional details requested respective to the line group as a
        /// comma separated list. As a default service returns line basic info.
        /// Supported values are:
        /// * `alerts` - Return any active service alerts for the specified stop.
        /// Response provides brief information for disruption in service and all basic
        /// data associated with the alert.
        /// * `alertDetails` - Can only be used in conjunction with
        /// detailType=alerts.Return additional details associated with the active
        /// service alerts.
        /// * `lines` - Return transit lines that stops at the specified stop.
        /// * `stops` - Return list of stops the line group goes through.
        /// * `schedule` - Return a 24h static schedule for the specified line group
        /// from the current time of the day to the end of the current day.
        /// * `patterns` - Return list of patterns this group is comprised of. A
        /// pattern consists of a stop sequence and shape per line.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TransitLineInfoResponse>> GetTransitLineInfoPreviewWithHttpMessagesAsync(string query, int? metroId = default(int?), IList<string> detailType = default(IList<string>), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("metroId", metroId);
                tracingParameters.Add("query", query);
                tracingParameters.Add("detailType", detailType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTransitLineInfoPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/transit/line/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (metroId != null)
            {
                _queryParameters.Add(string.Format("metroId={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(metroId, Client.SerializationSettings).Trim('"'))));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (detailType != null)
            {
                _queryParameters.Add(string.Format("detailType={0}", System.Uri.EscapeDataString(string.Join(",", detailType))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TransitLineInfoResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TransitLineInfoResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Transit Stop Info API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Get Transit Stop Info service allows you to request information for a given
        /// public transit stop. Basic information returned includes  details such as
        /// main transit type of most lines stopping for a given public and main
        /// transport agency. Additional details such as stop  lines and active service
        /// alerts for specified stop are also available, depending on the options
        /// selected.
        /// </summary>
        /// <param name='query'>
        /// The stopId or stopKey for which the user is requesting transit stop
        /// details.
        /// </param>
        /// <param name='metroId'>
        /// The unique id of the metro area. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityMetro).
        /// </param>
        /// <param name='queryType'>
        /// The type of the unique query parameter of the stop. By default
        /// queryType=stopId. Possible values include: 'stopId', 'stopKey'
        /// </param>
        /// <param name='detailType'>
        /// Specify additional details requested respective to the transit stop as a
        /// comma separated list. Supported values are:
        /// * `alerts` - Return any active service alerts for the specified stop.
        /// Response provides brief information for disruption in service and all basic
        /// data associated with the alert.
        /// * `alertDetails` - Can only be used in conjunction with
        /// detailType=alerts.Return additional details associated with the active
        /// service alerts.
        /// * `lines` - Return transit lines that stops at the specified stop.
        /// * `lineGroups` - Return line groups that stops at the specified stop.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TransitStopInfoResponse>> GetTransitStopInfoPreviewWithHttpMessagesAsync(string query, int? metroId = default(int?), string queryType = default(string), IList<string> detailType = default(IList<string>), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("metroId", metroId);
                tracingParameters.Add("query", query);
                tracingParameters.Add("queryType", queryType);
                tracingParameters.Add("detailType", detailType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTransitStopInfoPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/transit/stop/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (metroId != null)
            {
                _queryParameters.Add(string.Format("metroId={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(metroId, Client.SerializationSettings).Trim('"'))));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (queryType != null)
            {
                _queryParameters.Add(string.Format("queryType={0}", System.Uri.EscapeDataString(queryType)));
            }
            if (detailType != null)
            {
                _queryParameters.Add(string.Format("detailType={0}", System.Uri.EscapeDataString(string.Join(",", detailType))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TransitStopInfoResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TransitStopInfoResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Transit Route API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Get Transit Route API will allow trip planning returning the best possible
        /// route options between an origin and destination by using multi-modal
        /// search. Service provides a variety of travel modes, including walk, bike,
        /// and public transit.  The API supports parameters to request one or multiple
        /// public transit types such as bus, tram and subway, and prefer a specific
        /// transit agency operating in the area. Also, service provides transit fare
        /// details and options to choose optimal route with least walk or transfers
        /// and specify arrival or departure times when user need to be at a specific
        /// destination by a certain time.
        /// </summary>
        /// <param name='origin'>
        /// The origin of the route. By default originType=position, specified as a
        /// comma separated string composed by latitude followed by longitude, e.g.
        /// "47.641268,-122.125679‚Äù.
        /// </param>
        /// <param name='destination'>
        /// The destination of the route. By default the destinationType=position,
        /// specified as a comma separated string composed by latitude followed by
        /// longitude, e.g. "47.641268,-122.125679‚Äù.
        /// </param>
        /// <param name='metroId'>
        /// The unique id of the metro area. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityMetro).
        /// </param>
        /// <param name='originType'>
        /// The type of the origin. By default originType=position, specified as a
        /// comma separated string composed by latitude followed by longitude, e.g.,
        /// "47.641268,-122.125679‚Äù. Possible values include: 'position', 'stopId',
        /// 'stopKey'
        /// </param>
        /// <param name='destinationType'>
        /// The type of the destination. Possible values include: 'position', 'stopId',
        /// 'stopKey'
        /// </param>
        /// <param name='modeType'>
        /// The mode of travel for the requested route; as comma separated list. If not
        /// specified, all modes will be allowed. All modes might not be available in
        /// all metro areas. If valid trip is not found, empty result will be returned.
        /// Supported values are:
        /// * `walk` - Walk (pedestrian)
        /// * `bike` - Bike
        /// * `publicTransit` - Public transit
        /// </param>
        /// <param name='transitType'>
        /// Applicable only with modeType = publicTransit. Allow only a specific set of
        /// public transit types (as a comma separated list) to be returned for the
        /// route.  Note that the requested transitType may not be available for the
        /// entire route. If not specified, all modes will be allowed. Supported values
        /// are:
        /// * `bus` - Bus
        /// * `cableCar` - Cable car
        /// * `ferry` - Ferry
        /// * `funicular` - Funicular
        /// * `gondola` - Gondola
        /// * `rail` - Rail
        /// * `tram` - Tram
        /// * `subway` - Subway/Metro
        /// </param>
        /// <param name='agency'>
        /// Specifies whether to prefer routes from a specific set of agencies if
        /// possible; as a comma separated list. If valid trip isn‚Äôt found with the
        /// preferred agency, or only one with very long trips or with large number of
        /// transfers, itineraries with other agencies will be returned.
        /// </param>
        /// <param name='agencyType'>
        /// Specifies the agency identifier to request routes from preferred agencies.
        /// By default the agencyType=agencyId. Possible values include: 'agencyId',
        /// 'agencyKey', 'agencyName'
        /// </param>
        /// <param name='time'>
        /// The time of departure or arrival in the local time in ISO format
        /// (2019-04-05T14:24:18-04:00). If timeType is not specified, it will be
        /// assumed to be 'departure' and time is the current local time at the origin
        /// point.
        /// </param>
        /// <param name='timeType'>
        /// Specifies whether the time signifies departure time or arrival time. If not
        /// defined, default value is 'departure'. Possible values include: 'arrival',
        /// 'departure', 'last'
        /// </param>
        /// <param name='routeType'>
        /// The type of route requested. If not specified, 'optimal' will be used.
        /// Possible values include: 'optimal', 'leastWalk', 'leastTransfers'
        /// </param>
        /// <param name='bikeType'>
        /// Bike type of the bike. Specifies which type of bikes will be used. Only
        /// private bikes are supported.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TransitRouteResponse>> GetTransitRoutePreviewWithHttpMessagesAsync(string origin, string destination, int? metroId = default(int?), string originType = default(string), string destinationType = default(string), IList<string> modeType = default(IList<string>), IList<string> transitType = default(IList<string>), IList<string> agency = default(IList<string>), string agencyType = default(string), string time = default(string), string timeType = default(string), string routeType = default(string), string bikeType = default(string), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (origin == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "origin");
            }
            if (destination == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "destination");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("metroId", metroId);
                tracingParameters.Add("origin", origin);
                tracingParameters.Add("originType", originType);
                tracingParameters.Add("destination", destination);
                tracingParameters.Add("destinationType", destinationType);
                tracingParameters.Add("modeType", modeType);
                tracingParameters.Add("transitType", transitType);
                tracingParameters.Add("agency", agency);
                tracingParameters.Add("agencyType", agencyType);
                tracingParameters.Add("time", time);
                tracingParameters.Add("timeType", timeType);
                tracingParameters.Add("routeType", routeType);
                tracingParameters.Add("bikeType", bikeType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTransitRoutePreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/transit/route/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (metroId != null)
            {
                _queryParameters.Add(string.Format("metroId={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(metroId, Client.SerializationSettings).Trim('"'))));
            }
            if (origin != null)
            {
                _queryParameters.Add(string.Format("origin={0}", System.Uri.EscapeDataString(origin)));
            }
            if (originType != null)
            {
                _queryParameters.Add(string.Format("originType={0}", System.Uri.EscapeDataString(originType)));
            }
            if (destination != null)
            {
                _queryParameters.Add(string.Format("destination={0}", System.Uri.EscapeDataString(destination)));
            }
            if (destinationType != null)
            {
                _queryParameters.Add(string.Format("destinationType={0}", System.Uri.EscapeDataString(destinationType)));
            }
            if (modeType != null)
            {
                _queryParameters.Add(string.Format("modeType={0}", System.Uri.EscapeDataString(string.Join(",", modeType))));
            }
            if (transitType != null)
            {
                _queryParameters.Add(string.Format("transitType={0}", System.Uri.EscapeDataString(string.Join(",", transitType))));
            }
            if (agency != null)
            {
                _queryParameters.Add(string.Format("agency={0}", System.Uri.EscapeDataString(string.Join(",", agency))));
            }
            if (agencyType != null)
            {
                _queryParameters.Add(string.Format("agencyType={0}", System.Uri.EscapeDataString(agencyType)));
            }
            if (time != null)
            {
                _queryParameters.Add(string.Format("time={0}", System.Uri.EscapeDataString(time)));
            }
            if (timeType != null)
            {
                _queryParameters.Add(string.Format("timeType={0}", System.Uri.EscapeDataString(timeType)));
            }
            if (routeType != null)
            {
                _queryParameters.Add(string.Format("routeType={0}", System.Uri.EscapeDataString(routeType)));
            }
            if (bikeType != null)
            {
                _queryParameters.Add(string.Format("bikeType={0}", System.Uri.EscapeDataString(bikeType)));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TransitRouteResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TransitRouteResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Transit Itinerary API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Returns data according to an itinerary Id previously returned by [Transit
        /// Route API](https://aka.ms/AzureMapsMobilityTransitRoute). The basic info
        /// contains data as to the various legs comprising  the itinerary, including
        /// the locations, public transit lines, start and end times and fare
        /// information. Users can request additional routing information such as the
        /// shape of the itinerary and detailed itinerary schedules is also available,
        /// depending on the options selected. An itinerary is available up to 24
        /// hours following a search request.
        /// </summary>
        /// <param name='query'>
        /// The unique id (itineraryId) of an itinerary previously returned by [Transit
        /// Route API](https://aka.ms/AzureMapsMobilityTransitRoute).
        /// </param>
        /// <param name='detailType'>
        /// Specify additional details returned in the transit route itinerary
        /// response, as a comma separated list. Supported values are:
        /// * `geometry` - Shape of an in GeoJSON format. For public transit legs will
        /// return also the stops that the leg passes through. For walk and bike legs,
        /// will return also the turn-by-turn navigation data.
        /// * `schedule` - Static schedule data as to all departures of Public Transit
        /// legs from the current time of the day to the end of the current day.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<TransitItineraryResponse>> GetTransitItineraryPreviewWithHttpMessagesAsync(string query, IList<string> detailType = default(IList<string>), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("query", query);
                tracingParameters.Add("detailType", detailType);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetTransitItineraryPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/transit/itinerary/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (detailType != null)
            {
                _queryParameters.Add(string.Format("detailType={0}", System.Uri.EscapeDataString(string.Join(",", detailType))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<TransitItineraryResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<TransitItineraryResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

        /// <summary>
        /// **Real-time Arrivals API**
        ///
        /// **Applies to**: S1 pricing tier.
        ///
        /// Get Real Time Arrivals API returns for a given a stop, line or location the
        /// requested number of real-time arrivals. Endpoint support different modes to
        /// request real-time arrivals such as number of live arrivals for all lines
        /// arriving at the specified stop or all arrivals of a line to stops near the
        /// user‚Äôs location. The API supports parameters to request one or multiple
        /// public transit types such as bus, tram and subway, maximum number if
        /// arrivals, and prefer a specific transit agency operating in the area. In
        /// some cases real-time arrivals may not be available, for example, if arrival
        /// is too far in the future or transit vehicle does not have capability to
        /// share the real-time location. This is symbolized in a scheduleType field
        /// present in all responses.
        /// </summary>
        /// <param name='query'>
        /// Stop, line or location identifier.
        /// </param>
        /// <param name='metroId'>
        /// The unique id of the metro area. Can be retrieved via [Get Metro Area
        /// API](https://aka.ms/AzureMapsMobilityMetro).
        /// </param>
        /// <param name='queryType'>
        /// The type of the query parameter. Defines the mode of the request. Only one
        /// mode per request is supported. By default queryType is set to be ‚Äòstops‚Äô
        /// returning the requested number of Live Arrivals for all lines arriving at
        /// the specified stop. Possible values include: 'stops', 'line',
        /// 'lineAndStop', 'position'
        /// </param>
        /// <param name='stopQueryType'>
        /// The type of the unique query parameter of the stop. By default
        /// stopQueryType=stopId. This parameter can only be used in conjunction with
        /// queryType=stops or queryType=lineAndStop. Possible values include:
        /// 'stopId', 'stopKey'
        /// </param>
        /// <param name='limit'>
        /// The maximum arrivals to return. If not specified, the system default will
        /// be used. For stops max number of arrivals per stop. For lines max arrivals
        /// per stop on the line. For everything else max arrivals overall.
        /// </param>
        /// <param name='maxMinutesInFuture'>
        /// The maximum time (in minutes) in the future to return arrivals for. If not
        /// specified, the system default (30 minutes) will be used.  The minimum value
        /// is 0 and maximum value is 60 minutes.
        /// </param>
        /// <param name='transitType'>
        /// Type of public transit user is requesting respective transit stop, as a
        /// comma separated list. For example, transitType=Bus,Subway. If not
        /// specified, all will be allowed. This parameter can only be used in
        /// conjunction with queryType=stops. Supported values are:
        /// * `bus` - Bus
        /// * `cableCar` - Cable car
        /// * `ferry` - Ferry
        /// * `funicular` - Funicular
        /// * `gondola` - Gondola
        /// * `rail` - Rail
        /// * `tram` - Tram
        /// * `subway` - Subway/Metro
        /// </param>
        /// <param name='agency'>
        /// In case you prefer routes from a specific set of agencies to be returned.
        /// Specified as a comma separated string.
        /// </param>
        /// <param name='agencyType'>
        /// Specifies the agency identifier to request routes from a specific set of
        /// agencies to be returned. By default the agencyType=agencyId. Possible
        /// values include: 'agencyId', 'agencyKey', 'agencyName'
        /// </param>
        /// <param name='timeoutInSeconds'>
        /// Time in seconds within which if the provider doesn‚Äôt respond, end point
        /// will return static data.
        /// </param>
        /// <param name='language'>
        /// Language in which search results will be returned.  Only NGT is supported.
        /// Please refer to [Supported
        /// languages](https://docs.microsoft.com/azure/azure-maps/supported-languages)
        /// for details.
        /// </param>
        /// <param name='customHeaders'>
        /// Headers that will be added to request.
        /// </param>
        /// <param name='cancellationToken'>
        /// The cancellation token.
        /// </param>
        /// <exception cref="ErrorResponseException">
        /// Thrown when the operation returned an invalid status code
        /// </exception>
        /// <exception cref="SerializationException">
        /// Thrown when unable to deserialize the response
        /// </exception>
        /// <exception cref="ValidationException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <exception cref="System.ArgumentNullException">
        /// Thrown when a required parameter is null
        /// </exception>
        /// <return>
        /// A response object containing the response body and response headers.
        /// </return>
        public async Task<HttpOperationResponse<RealTimeArrivalsResponse>> GetRealTimeArrivalsPreviewWithHttpMessagesAsync(string query, int? metroId = default(int?), string queryType = default(string), string stopQueryType = default(string), int? limit = default(int?), int? maxMinutesInFuture = default(int?), IList<string> transitType = default(IList<string>), IList<string> agency = default(IList<string>), string agencyType = default(string), int? timeoutInSeconds = default(int?), string language = default(string), Dictionary<string, List<string>> customHeaders = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (Client.Geography == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.Geography");
            }
            if (Client.ApiVersion == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "this.Client.ApiVersion");
            }
            if (query == null)
            {
                throw new ValidationException(ValidationRules.CannotBeNull, "query");
            }
            string format = "json";
            // Tracing
            bool _shouldTrace = ServiceClientTracing.IsEnabled;
            string _invocationId = null;
            if (_shouldTrace)
            {
                _invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("format", format);
                tracingParameters.Add("metroId", metroId);
                tracingParameters.Add("query", query);
                tracingParameters.Add("queryType", queryType);
                tracingParameters.Add("stopQueryType", stopQueryType);
                tracingParameters.Add("limit", limit);
                tracingParameters.Add("maxMinutesInFuture", maxMinutesInFuture);
                tracingParameters.Add("transitType", transitType);
                tracingParameters.Add("agency", agency);
                tracingParameters.Add("agencyType", agencyType);
                tracingParameters.Add("timeoutInSeconds", timeoutInSeconds);
                tracingParameters.Add("language", language);
                tracingParameters.Add("cancellationToken", cancellationToken);
                ServiceClientTracing.Enter(_invocationId, this, "GetRealTimeArrivalsPreview", tracingParameters);
            }
            // Construct URL
            var _baseUrl = Client.BaseUri;
            var _url = _baseUrl + (_baseUrl.EndsWith("/") ? "" : "/") + "mobility/realtime/arrivals/{format}";
            _url = _url.Replace("{geography}", System.Uri.EscapeDataString(Client.Geography));
            _url = _url.Replace("{format}", System.Uri.EscapeDataString(format));
            List<string> _queryParameters = new List<string>();
            if (Client.ApiVersion != null)
            {
                _queryParameters.Add(string.Format("api-version={0}", System.Uri.EscapeDataString(Client.ApiVersion)));
            }
            if (metroId != null)
            {
                _queryParameters.Add(string.Format("metroId={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(metroId, Client.SerializationSettings).Trim('"'))));
            }
            if (query != null)
            {
                _queryParameters.Add(string.Format("query={0}", System.Uri.EscapeDataString(query)));
            }
            if (queryType != null)
            {
                _queryParameters.Add(string.Format("queryType={0}", System.Uri.EscapeDataString(queryType)));
            }
            if (stopQueryType != null)
            {
                _queryParameters.Add(string.Format("stopQueryType={0}", System.Uri.EscapeDataString(stopQueryType)));
            }
            if (limit != null)
            {
                _queryParameters.Add(string.Format("limit={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(limit, Client.SerializationSettings).Trim('"'))));
            }
            if (maxMinutesInFuture != null)
            {
                _queryParameters.Add(string.Format("maxMinutesInFuture={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(maxMinutesInFuture, Client.SerializationSettings).Trim('"'))));
            }
            if (transitType != null)
            {
                _queryParameters.Add(string.Format("transitType={0}", System.Uri.EscapeDataString(string.Join(",", transitType))));
            }
            if (agency != null)
            {
                _queryParameters.Add(string.Format("agency={0}", System.Uri.EscapeDataString(string.Join(",", agency))));
            }
            if (agencyType != null)
            {
                _queryParameters.Add(string.Format("agencyType={0}", System.Uri.EscapeDataString(agencyType)));
            }
            if (timeoutInSeconds != null)
            {
                _queryParameters.Add(string.Format("timeoutInSeconds={0}", System.Uri.EscapeDataString(Microsoft.Rest.Serialization.SafeJsonConvert.SerializeObject(timeoutInSeconds, Client.SerializationSettings).Trim('"'))));
            }
            if (language != null)
            {
                _queryParameters.Add(string.Format("language={0}", System.Uri.EscapeDataString(language)));
            }
            if (_queryParameters.Count > 0)
            {
                _url += "?" + string.Join("&", _queryParameters);
            }
            // Create HTTP transport objects
            var _httpRequest = new HttpRequestMessage();
            HttpResponseMessage _httpResponse = null;
            _httpRequest.Method = new HttpMethod("GET");
            _httpRequest.RequestUri = new System.Uri(_url);
            // Set Headers
            if (Client.XMsClientId != null)
            {
                if (_httpRequest.Headers.Contains("x-ms-client-id"))
                {
                    _httpRequest.Headers.Remove("x-ms-client-id");
                }
                _httpRequest.Headers.TryAddWithoutValidation("x-ms-client-id", Client.XMsClientId);
            }


            if (customHeaders != null)
            {
                foreach(var _header in customHeaders)
                {
                    if (_httpRequest.Headers.Contains(_header.Key))
                    {
                        _httpRequest.Headers.Remove(_header.Key);
                    }
                    _httpRequest.Headers.TryAddWithoutValidation(_header.Key, _header.Value);
                }
            }

            // Serialize Request
            string _requestContent = null;
            // Set Credentials
            if (Client.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await Client.Credentials.ProcessHttpRequestAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            }
            // Send Request
            if (_shouldTrace)
            {
                ServiceClientTracing.SendRequest(_invocationId, _httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            _httpResponse = await Client.HttpClient.SendAsync(_httpRequest, cancellationToken).ConfigureAwait(false);
            if (_shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(_invocationId, _httpResponse);
            }
            HttpStatusCode _statusCode = _httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string _responseContent = null;
            if ((int)_statusCode != 200)
            {
                var ex = new ErrorResponseException(string.Format("Operation returned an invalid status code '{0}'", _statusCode));
                try
                {
                    _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    ErrorResponse _errorBody =  Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<ErrorResponse>(_responseContent, Client.DeserializationSettings);
                    if (_errorBody != null)
                    {
                        ex.Body = _errorBody;
                    }
                }
                catch (JsonException)
                {
                    // Ignore the exception
                }
                ex.Request = new HttpRequestMessageWrapper(_httpRequest, _requestContent);
                ex.Response = new HttpResponseMessageWrapper(_httpResponse, _responseContent);
                if (_shouldTrace)
                {
                    ServiceClientTracing.Error(_invocationId, ex);
                }
                _httpRequest.Dispose();
                if (_httpResponse != null)
                {
                    _httpResponse.Dispose();
                }
                throw ex;
            }
            // Create Result
            var _result = new HttpOperationResponse<RealTimeArrivalsResponse>();
            _result.Request = _httpRequest;
            _result.Response = _httpResponse;
            // Deserialize Response
            if ((int)_statusCode == 200)
            {
                _responseContent = await _httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                try
                {
                    _result.Body = Microsoft.Rest.Serialization.SafeJsonConvert.DeserializeObject<RealTimeArrivalsResponse>(_responseContent, Client.DeserializationSettings);
                }
                catch (JsonException ex)
                {
                    _httpRequest.Dispose();
                    if (_httpResponse != null)
                    {
                        _httpResponse.Dispose();
                    }
                    throw new SerializationException("Unable to deserialize the response.", _responseContent, ex);
                }
            }
            if (_shouldTrace)
            {
                ServiceClientTracing.Exit(_invocationId, _result);
            }
            return _result;
        }

    }
}
